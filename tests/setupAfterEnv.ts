import { isExecaError } from './helpers';

declare global {
  // Using `namespace` here is okay because this is how the Jest types are
  // defined.
  /* eslint-disable-next-line @typescript-eslint/no-namespace */
  namespace jest {
    interface Matchers<R> {
      toResolve(): Promise<R>;
      toThrowExecaError(
        message: string | RegExp,
        options?: { replacements?: { from: string | RegExp; to: string }[] },
      ): Promise<R>;
    }
  }
}

// Export something so that TypeScript thinks that we are performing type
// augmentation
export {};

const UNRESOLVED = Symbol('timedOut');
// Store this in case it gets stubbed later
const originalSetTimeout = global.setTimeout;
const TIME_TO_WAIT_UNTIL_UNRESOLVED = 100;
const START = '▼▼▼ START ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼';
const END = '▲▲▲ END ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲';

/**
 * Produces a sort of dummy promise which can be used in conjunction with a
 * "real" promise to determine whether the "real" promise was ever resolved. If
 * the promise that is produced by this function resolves first, then the other
 * one must be unresolved.
 *
 * @param duration - How long to wait before resolving the promise returned by
 * this function.
 * @returns A promise that resolves to a symbol.
 */
const treatUnresolvedAfter = (duration: number): Promise<typeof UNRESOLVED> => {
  return new Promise((resolve) => {
    originalSetTimeout(resolve, duration, UNRESOLVED);
  });
};

expect.extend({
  /**
   * Tests that the given promise is resolved within a certain amount of time
   * (which defaults to the time that Jest tests wait before timing out as
   * configured in the Jest configuration file).
   *
   * Inspired by <https://stackoverflow.com/a/68409467/260771>.
   *
   * @param promise - The promise to test.
   * @returns The result of the matcher.
   */
  async toResolve(promise: Promise<any>) {
    if (this.isNot) {
      throw new Error('Using `.not.toResolve(...)` is not supported.');
    }

    let resolutionValue: any;
    let rejectionValue: any;

    try {
      resolutionValue = await Promise.race([
        promise,
        treatUnresolvedAfter(TIME_TO_WAIT_UNTIL_UNRESOLVED),
      ]);
    } catch (e) {
      rejectionValue = e;
    }

    return rejectionValue !== undefined || resolutionValue === UNRESOLVED
      ? {
          message: () => {
            return `Expected promise to resolve after ${TIME_TO_WAIT_UNTIL_UNRESOLVED}ms, but it ${
              rejectionValue === undefined ? 'did not' : 'was rejected'
            }.`;
          },
          pass: false,
        }
      : {
          message: () =>
            `This message should never get produced because .isNot is disallowed.`,
          pass: true,
        };
  },

  async toThrowExecaError(
    error: unknown,
    message: string | RegExp,
    {
      replacements = [],
    }: { replacements?: { from: string | RegExp; to: string }[] } = {},
  ) {
    if (isExecaError(error)) {
      const stderr = [
        {
          from: /^\s+at.+\)$/msu,
          to: '<<backtrace>>',
        },
        ...replacements,
      ].reduce((string, { from, to }) => {
        return string.replace(from, to);
      }, error.stderr);

      const pass =
        message instanceof RegExp ? message.test(stderr) : stderr === message;

      if (pass) {
        return {
          message: () =>
            'Expected the tool not to error with the given message, but it did',
          pass: true,
        };
      }

      return {
        message: () =>
          `Expected the tool to error with:\n\n${START}\n${message}\n${END}\n\nBut it errored instead with:\n\n${START}\n${stderr}\n${END}`,
        pass: false,
      };
    }

    return {
      message: () =>
        `Expected the tool to error using a message generated by \`execa\`, but it errored with:\n\n${error}`,
      pass: false,
    };
  },
});
